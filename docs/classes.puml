@startuml

package RBF {

    note as N1
    int RC
    --
    PAGE_SIZE 4096
    PageNum: unsigned
    PageFreeSpace: unsigned short
    PAGES_IN_FSP (PAGE_SIZE / sizeof(PageFreeSpace))
    -- DataPage --
    SlotNumber: unsigned short
    RecordNumber: unsigned short
    InitIndicator: char
    SlotPointerIndicator: bool
    RecordOffset: unsigned
    RecordLength: unsigned short
    -- Record --
    FieldNumber: unsigned short
    FieldOffset: unsigned short
    -- Attribute --
    AttrLength: unsigned
    end note

    PagedFileManager ..|> FileHandle
    FileHandle --|> FreeSpacePage
    FileHandle -- DataPage
    DataPage ..|> Record

    class PagedFileManager {
        {static} +PagedFileManager &instance()
        +RC createFile(fileName)
        +RC destroyFile(fileName)
        +RC openFile(fileName, fileHandle)
        +RC closeFile(fileHandle);
    }

    class FileHandle {
        -- private members --
        -fstream *handle
        -void *fspData
        -FreeSpacePage curFSP
        -PageNum curFSPNum
        -- public members --
        +Counter readPageCounter
        +Counter writePageCounter
        +Counter appendPageCounter
        +PageNum totalPageNum
        +PageNum dataPageNum
        -- private methods --
        -RC writeHiddenPage()
        -RC readHiddenPage()
        -- public methods --
        +FileHandle()
        +~FileHandle()
        +RC collectCounterValues(Counter &rc, Counter &wc, Counter &ac)
        ..
        +RC setHandle(fstream *f)
        +RC releaseHandle()
        +bool isOccupied()
        ..
        {static} +PageNum changeToActualPageNum(PageNum dataPageNum)
        +RC readPage(pageNum, *data, bool actual=false)
        +RC writePage(pageNum, *data, bool actual=false)
        // pageNum is data page number
        +RC writePage(pageNum, freeSpace, *data)
        +RC appendPage(*data, bool dataPage=true)
        +RC appendPage(freeSpace, *data)
        ..
        +int getNumberOfPages()  // data page number
        +int getActualNumberOfPages()
        ..
        // pageNum below -> data page number
        {static} +void getFSPofPage(dataPageNum, fspNum, pageIndex)
        +RC updateCurFSP(fspNum)
        +PageFreeSpace getFreeSpaceOfPage(dataPageNum)
        +void updateFreeSpaceOfPage(dataPageNum, freePageSpace)
    }

    note top of DataPage
    -- Page Format --
    Data Section
    --
    Slot Directory      Record Number    Slot Number    Inited
    ...
    <isPointer, offset, len>
    end note

    class DataPage {
        {static} +unsigned SlotSize
        {static} +unsigned InfoSize
        {static} +RecordOffset DeletedRecordOffset
        --
        -void *page
        -PageFreeSpace freeSpace
        -SlotNumber slotNumber
        -RecordNumber recordNumber
        -int freeSpaceOffset
        --
        // n starts from 0
        -{static} int getNthSlotOffset(n)
        -SlotNumber getFirstAvailableSlot()
        -void parseSlot(slot, isPointer, recordOffset, recordLen)
        -void updateSlotInfo(offset, length, bool dir);
        --
        +DataPage(*data)
        +~DataPage() = default
        +void deleteSlot(slot)
        +RecordLength getRecordSize(slot)
        +SlotNumber getSlotNumber()
        +SlotNumber insertRecord(record)
        +void *readRecord(SlotNumber slot)
        +void readRecordIntoRaw(slot, &recordDescriptor, *data)
        +void deleteRecord(slotID)
        +void updateRecord(&updateRecord, &slotid)
        +void moveRecord(slot, &newRID)
        +void *getPageData()
        +int getFreeSpace()
        +int checkRecordExist(&slotid, &newRID)
        +void moveRecords(RecordOffset startOffset, targetOffset);
    }

    class FreeSpacePage {
        -void *page
        --
        +FreeSpacePage() = default
        +~FreeSpacePage() = default
        +FreeSpacePage(*data)
        +void loadNewPage(*data)
        // pageIndex -> index in this fsp, starts from 0
        +void writeFreeSpace(pageIndex, freeSpace)
        +PageFreeSpace getFreeSpace(pageIndex)
    }

    Record ..|> RID

    class RID <<(S,orchid) Structure>> {
        pageNum: unsigned
        slotNum: unsigned short
    }

    class AttrType <<(E, orange) Enum>> {
        TypeInt = 0
        TypeReal
        TypeVarChar
        TypeNull
    }

    Attribute --|>AttrType
    Record ..|> Attribute

    class Attribute <<(S, orchid) Structure>> {
        name: string
        type: AttrType
        length: AttrLength
    }

    class Record {
        {static} -unsigned short RecordHeaderSize
        -int size
        -void *record
        -FieldNumber fieldNumber
        -RecordVersion recordVersion
        -bool passedData
        -- private methods --
        {static} -int getRecordActualSize(nullIndicatorSize, rDescriptor, *data);
        {static} -int getNullIndicatorSize(fieldNumber)
        {static} -bool isFieldNull(fieldIndex, *nullIndicatorData)
        -- public methods --
        +Record(*data)
        +Record(rDescriptor, *data)
        +~Record()
        ..
        +int getSize()
        +void *getRecordData()
        +void convertToRawData(rDescriptor, *data)
        +void printRecord(recordDescriptor);
        +void *getFieldValue(FieldNumber &fieldIndex)
        -- UNIMPLEMENTED --
        +
    }

    note left of Record
    Record Format
    ----
    RecordHeader                           OffsetSection             FieldData
    RecordVersion, FieldNumber    offset, ..., offset     Field 1,...,Field N
    end note
}

package RBFM {

    note as N2
    RBMF_EOF  -1
    end note

    class CompOp<<(E, orange) Enum>> {
        EQ_OP = 0, // no condition// =
        LT_OP,      // <
        LE_OP,      // <=
        GT_OP,      // >
        GE_OP,      // >=
        NE_OP,      // !=
        NO_OP       // no condition
    }

    class RBFM_ScanIterator {
        FileHandle *fileHandle
        std::vector<Attribute> descriptor
        std::vector<Attribute> projectedDescriptor
        FieldNumber conditionAttrFieldIndex
        Attribute conditionAttr
        CompOp compOp = NO_OP
        void *value = nullptr
        PageNum curPageNum
        SlotNumber nextSlotNum
        void *curPageData = nullptr
        --
        -void parseValue(void *rawValue, string &conditionAttrName)
        -int compare(const void *recordAttrData)
        --
        +void setUp(&recordDescriptor, &conditionAttribute, compOp, void *value, &attributeNames, &rbfm_ScanIterator)
        +RC getNextRecord(&rid, *data)
        +RC close()
    }

    DataPage <|-- RecordBasedFileManager
    Record <|-- RecordBasedFileManager
    RecordBasedFileManager --|> PagedFileManager
    RecordBasedFileManager --|> RBFM_ScanIterator
    RecordBasedFileManager ..|> CompOp

    class RecordBasedFileManager {
        --
        -RC getFirstPageAvailable(fileHandle, freeSize, pageNum)
        {static} -int findRecordActualRID(&fileHandle, &rid, deletePointer=false)
        --
        {static} +RecordBasedFileManager &instance()
        +RC createFile(fileName)
        +RC destroyFile(fileName)
        +RC openFile(fileName, fileHandle)
        +RC closeFile(fileHandle)
        ..
        +RC insertRecord(fileHandle, recordDescriptor, *data, rid)
        +RC readRecord(fileHandle, rDescriptor, rid, *data)
        +RC printRecord(rDescriptor, *data)
        +RC deleteRecord(fileHandle, rDescriptor, rid)
        +RC updateRecord(fileHandle, rDescriptor, *data, rid)
        +RC readAttribute(fileHandle, rDescriptor, rid, attributeName, *data)
        +RC scan(fileHandle, rDescriptor, &conditionAttribute, compOp, *value, &attributeNames, &rbfm_ScanIterator)
        --
        #RecordBasedFileManager()
        #~RecordBasedFileManager()
        #RecordBasedFileManager(const RecordBasedFileManager &)
        #RecordBasedFileManager &operator=(const RecordBasedFileManager &)
    }

}

package RM {
    note as N3
    RM_EOF -1
    end note

    class RM_ScanIterator {
        +FileHandle fileHandle
        +RBFM_ScanIterator rbfm_ScanIterator
        --
        +void setUp(&tableFileName, &conditionAttribute, compOp, void *value, &attributeNames, descriptor)
        +RC getNextTuple(&rid, *data)
        +RC close()
    }

    class RelationManager {
        {static} +RelationManager &instance()
        +RC createCatalog()
        +RC deleteCatalog()
        +RC createTable(&tableName, vector<Attribute> &attrs)
        +RC deleteTable(&tableName)
        +RC getAttributes(&tableName, vector<Attribute> &attrs)
        +RC insertTuple(&tableName, *data, &rid)
        +RC deleteTuple(&tableName, &rid)
        +RC updateTuple(&tableName, *data, &rid)
        +RC readTuple(&tableName, &rid, *data)
        +RC printTuple(vector<Attribute> &attrs, *data)
        +RC readAttribute(&tableName, &rid, &attributeName, *data)
        +RC scan(&tableName, &conditionAttribute, compOp, *value, &attributeNames, &rm_ScanIterator)
        +RC addAttribute(&tableName, &attr)
        +RC dropAttribute(&tableName, &attributeName)
        --
        -TableID tableNumber
        -RC insertTuple(&tableName, *data, &rid, sys);
        -RC deleteTuple(&tableName, &rid, sys);
        -void getSysTableAttributes(&descriptor)
        -void getSysColTableAttributes(&descriptor)
        -void addMetaInfo(&tableName, &descriptor)
        -int getTableNumber()
        -void addTablesInfo(&tableName, id)
        -void addColumnsInfo(&table, &descriptor)
        -void deleteMetaInfo(&tableName)
        -RC getTableInfo(&tableName, &id, &fileName)
        -void getDescriptorString(&descriptor, &attrNames)
        -bool isSysTable(tableName)
        --
        #RelationManager()
        #~RelationManager()
        #RelationManager(const RelationManager &)
        #RelationManager &operator=(const RelationManager &)
        --UNIMPLEMENTED--
        -void getTableInfo(&tableID, &fileHandle)
    }
}


@enduml